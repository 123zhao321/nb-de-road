#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


//好书推荐 ---- 《剑指offer》
// 
//指针的进阶
// 
//1.字符指针
//2.数组指针
//3.指针数组
//4.数组传参和指针传参
//5.函数指针
//6.函数指针数组
//7.指向函数指针数组的指针
//8. 回调函数
//9.指针和数组面试题的解析


//指针的主题，我们在初级阶段的《指针》章节已经接触过了，我们知道了指针的概念
//1.指针就是个变量，用来存放地址，地址唯一标识一块内存空间。
//2.指针的大小是固定的4 / 8个字节(32位平台 / 64位平台)。
//3.指针是有类型，指针的类型决定了指针的 + - 整数的步长，
//	指针解引用操作的时候的权限,
//4.指针的运算。

//int main()
//{
//	//char ch='q';
//	//char *p = &ch;
//	//本质上是把"hello bit"这个字符串的首字符的地址存储在了p中
//	char arr[] = "hello bit";
//
////char* ps = "hello bit"; // c++环境中不允许这么写
//	const char *ps = "hello bit.";//c++环境支持
//	printf("%c\n", *ps);
//	printf("%s\n", ps);
//
//	printf("%s\n", arr);
//	return 0;
//}


// 
//代码 char* p = ""he1lo bit."
//特别容易让同学以为是把字符串he1lo bit放到字符指针 p 里了，
//但本质是把字符串 "he11o bit." 首字符的地址放到了 p 中
// 
//这个字符串没有实体储存，对于c++这中比较严谨的环境中无法运行
//需要加上const修饰
//

// 面试题

//int main()
//{
//	char strl[] = "hello bit.";
//	char str2[] = "hello bit.";
//	char* str3 = "hello bit.";
//	char* str4 = "hello bit.";
//
//	if (strl == str2)
//		printf("strl and str2 are same\n");
//	else
//		printf("strl and str2 are not same\n");
//
//	if (str3 == str4)
//		printf("str3 and str4 are same\n");
//	else
//		printf("str3 and str4 are not same\n");
//	return 0;
//
//}

// 1，2 是字符串数组，是两个不同的地址储存字符串
// 3，4 都是指针指向内存中一个"hello bit"的地方，
// 这个字符串不动，两个指针的地址都是这个字符串
// 1，2不同，3，4相同
// 


// 
//int main()
//{
//	const char* p = "hello";
//	printf("%c\n", *p);
//	printf("%s\n", p);
//	//*p = 'w';//error
//	return 0;
//}

// 这种字符串叫 常量字符串，不可以被更改，
// 因此指针字符串用const修饰

//打印字符串只需要地址
//是因为字符串在内存中是以连续的字符数组的形式存储的，
//而地址所指向的就是该字符数组的起始位置。
//因此，只需要地址就可以访问整个字符串。
//
//打印字符需要解引用是因为字符是单个字符而不是字符数组，
//因此需要通过解引用操作来访问字符本身。
//解引用操作是从存储字符的地址中读取实际的字符值。
//因此，需要解引用才能访问和打印字符本身。


//指针数组
//数组 - 数组中存放的是指针(地址)
//int*arr[3];
//存放整形指针的数组

//int main()
//{
//	
//	int a = 10;
//	int b = 20;
//	int c = 30;
//	int* arr[3] = { &a,&b,&c };//这种写法太土了
//
//	int i = 0;
//	for (i = 0; i < 3; i++)
//		printf("%d ", *(arr[i]));// 数组的第i个元素，即第i个指针
//	return 0;
//}

// 指针数组
// 指针数组是一个数组，其中每个元素都是指针。
//

//int main()
//{
//	int a[] = { 1,2,3,4,5 };
//	int b[] = { 2,3,4,5,6 };
//	int c[] = { 3,4,5,6,7 };
//
//	int* pa[3] = { a,b,c };// 这是每个数组首元素的地址
//	// 一个叫pa的数组里面，存放了三个 int* 的指针
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d", pa[i][j]);
//			printf("%d", *pa[i] + j);
//			printf("%d", *(pa[i] + j));
//			printf("%d", *(*pa + i) + j);
//			printf("%d ", *(*(pa + i) + j));
//		}
//		printf("\n\n");
//	}
//	return 0;
//}

//上面这五种printf方式输出的一样，原来是测试用的样例不好

//int main()
//{
//	int a[] = { 5,10,15,20,25};
//	int b[] = { 4,8,12,16,20};
//	int c[] = { 3,6,9,12,15}; 
//	// 数据不该太紧密，以至于反复测试还找不到问题所在
//	int* pa[3] = { a,b,c };
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", pa[i][j]);
//		}
//		printf("\n");
//	}
//	printf("\n");
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *pa[i] + j); // ERROR!!!!!!
//		}
//		printf("\n");
//	}
//	printf("\n");
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(pa[i] + j));
//		}
//		printf("\n");
//	}
//	printf("\n");
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(*pa + i) + j); // ERROR!!!!!!!!!
//		}
//		printf("\n");
//	}
//	printf("\n");
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(*(pa + i) + j));
//		}
//		printf("\n");
//	}
//	return 0;
//}

// printf("%d ", pa[i][j]);
// printf("%d ", *pa[i] + j); // ERROR!!!!!!
// printf("%d ", *(pa[i] + j));
// printf("%d ", *(*pa + i) + j); // ERROR!!!!!!!!!
// printf("%d ", *(*(pa + i) + j));

// 修改样例后发现，第二个和第四个输出是有问题的
// 之前一直没发现问题，就是因为数据太紧密，没有及时检查出来
//

// 所以针对正确的指针数组进行分析吧
// 
// printf("%d ", pa[i][j]);
// printf("%d ", *(pa[i] + j));
// printf("%d ", *(*(pa + i) + j))；
// 
// 在c语言模式下，pa[i] 会被直接拆成 *(pa + i)
// 所以只需要搞明白第三个就可以了
// 
// *(*(pa + i) + j)，要由内向外分析
// 先分析 pa + i，就是 pa数组的第 i个元素的地址，
// *解引用就是第 i个元素，也就是第 i个指针指向的数组的首元素的地址
// 此时已经是 *( pa + i)，再 + j就是指向数组的第 j 个元素的地址
// 最后再 * 解引用，就是 pa数组的第 i个元素指向的数组的第 j 个元素
// 


// 数组名就是整个数组的情况主要有两种：       -------------------!!!
//
// 1. 当数组名作为函数参数传递时：当将数组名作为参数传递给函数时，
//    实际上传递的是数组的地址，但在函数内部，
//    数组名可以当做整个数组来使用。
//
//
//void printArray(int arr[])
//  {
//	// 在函数内部，arr 就是整个数组
//		for (int i = 0; i < 5; i++) 
//		{
//			printf("%d ", arr[i]);
//		}
//}
//
//int main() 
// {
//	int myArray[] = { 1, 2, 3, 4, 5 };
//	printArray(myArray); // 数组名 myArray 作为整个数组传递给函数
//	return 0;
//}
//
//
// 2. 使用 sizeof 运算符时：当使用 sizeof 运算符对数组名进行操作时，
//     返回的是整个数组所占内存空间的大小，而不是数组首元素的大小。
//
//int main() 
// {
//		int myArray[] = { 1, 2, 3, 4, 5 };
//		int size = sizeof(myArray); // 返回整个数组所占内存空间的大小
//		int elementSize = sizeof(myArray[0]); // 返回数组中单个元素的大小
//		return 0;
//}
//
// 在这些情况下，数组名被当做整个数组来使用，而不是数组首元素的地址。

// 除了作为函数参数传递和使用 sizeof 运算符的情况之外，
// 绝大多数情况下，数组名仅仅是指向数组首元素的地址。
// 在这些情况下，数组名可以被当做指向数组首元素的指针来使用，
// 可以进行指针运算、解引用等操作。因为数组在内存中是连续存储的，
// 所以数组名就是指向数组首元素的指针。
//
// 所以在大多数情况下，数组名可以当做首元素的地址来使用。


//
//数组指针
//数组指针的定义
//数组指针是指针 ? 还是数组 ?
//答案是 : 指针。
//我们已经熟悉 : 整形指针:int* p; 能够指向整形数据的指针。
//浮点型指针:float* pf; 能够指向浮点型数据的指针
//那数组指针应该是 : 能够指向数组的指针
// 


// 数组指针
// 数组指针是一个指向数组的指针，它存储的是数组的起始地址。


//int main()
//{
//	// 一个整型的指针
//	int a = 10;
//	int (*pa) = &a; // 这里一般是写成 int* pa = &a;有没有括号无所谓
//	printf("%d %d\n", a, *pa);
//	printf("%p %p\n", &a, pa);
//
//	// 一个整型数组的指针
//	int arr[10];
//	int(*parr)[10] = &arr;
//
//	// 一个整型指针数组的指针
//	int* arr1[10];
//	int* (*parr1)[10] = &arr1;
//
//	return 0;
//}


// 发现无论是什么类型的指针，都有一成不变的地方，即（*p）
// 在（）的左边，是指向内容的类型，比如：
// int a的类型就是int，就是int ( )
// int arr[10]的类型是int 有10个元素，就是int (  ) [10]
// int* arr1[10]的类型是int*，10个元素，就是 int* (  ) [10]
// 
// []里面的数字必须对应上
//

//&数组名VS数组名对于下面的数组
//int arr[10];
//arr 和& arr 分别是啥 ?
//我们知道arr是数组名，数组名表示数组首元素的地址。
//那 & arr数组名到底是啥 ?


//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr ); 
//	printf("%p\n", &arr);
//	return 0;
//}

//
//这两个值虽然一样，但是代表的意义不一样，就像下边的 97
//char c ='a' // 97 -char
//int i = 97; // 97 -int


//int main()
//{
//	int arr[10] = { 0 };
//
//	int* p = arr;
//	int(*p2)[10] = &arr;
//
//	printf("%p\n", p);
//	printf("%p\n", p + 1);
//
//	printf("%p\n", p2);
//	printf("%p\n", p2 + 1);
//	return 0;
//}

// 根据上面的代码我们发现，其实 &arr和 arr，
// 虽然值是一样的，但是意义应该不一样的。
// 实际上: &arr表示的是数组的地址，而不是数组首元素的地址。
// (细细体会一下)
// 数组的地址 + 1，跳过整个数组的大小，
// 所以 &arr + 1相对于 &arr的差值是 40.
// 


// 数组名是数组首元素的地址
// 但是有2个例外 :
// 1.sizeof(数组名)C数组名表示整个数组，
//       计算的是整个数组大小，单位是字节
// 2.&数组名 - 数组名表示整个数组，取出的是整个数组的地址


//void print2(int (*p)[5], int r, int c) // 因为arr是一维数组的地址
//{
//	int i = 0;
//	int j = 0;
//	for (i = 0; i < r; i++)
//	{
//		for (j = 0; j < c; j++)
//		{
//			printf("%d ", * (*(p + i) + j));
//		}
//		printf("\n");
//	}
//}
//	
//void print(int arr[3][5], int r, int c)
//{
//	int i = 0;
//	int j = 0;
//	for (i = 0; i < r; i++)
//	{
//		for (j = 0; j < c; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//		printf("\n");
//	}
//}
//
//int main()
//{
//	//int a[5]; 
//	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7 } };
//	// print(arr, 3，5);
//	print2(arr, 3, 5);  // arr数组名，表示数组首元素的地址
//						// arr只是第一行的地址，是一个一维数组
//						// &arr 才是二维数组的地址
//	return 0;
//}

//整型数组
//int arr[5]
//
//整型指针数组
//int *parr1[10]
//
//数组指针，是一个指针，指向一个数组，数组有10个元素，每个元素是int类型
//int (*parr2)[10]
//
//parr3是一个存储数组指针的数组该数组能能够存放10个数组指针
//每个数组指针能够指向一个数组，数组5个元素，每个元素是int类型
//int (*parr3[10])[5]
// 
//

// 一维数组传参

//void test(int arr[])//ok? 对
//{}
//void test(int arr[10])//ok? 对
//{}
//void test(int* arr)//ok? 对
//{}
//void test2(int* arr[20])//ok? 对
//{}
//void test2(int** arr) //ok?  对
//{}
//
//int main() 
//{
//	int arr[10] = { 0 };
//	int* arr2[20] = { 0 }; 
//	test(arr);
//	test2(arr2);
//}

//传参的时候，可以和传过去的类型相同，传过去一个数组，也用一个数组接收
//没任何问题，这也是最普通的方式
//对于一维数组 arr 来说，传过去的只是首元素的地址
//因此可以用一个int*的指针来接收
//
//
//arr2是一个指针数组，有20个int类型的指针


// 二维数组传参
void test(int arr[3][5])//ok? 对
{}
void test(int arr[][])//ok? 错，行可以省略，列不可以
{}
void test(int arr[][5])//ok? 对
{}

//总结:二维数组传参，函数形参的设计只能省略第一个[]的数字。
//因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素。
//这样才方便运算。

void test(int* arr)//ok? 错，因为二维数组的数组名是一个一维数组的地址
{}					// 是数组的地址，
void test(int* arr[5])//ok? 错，这是指针数组，不是指针
{}
void test(int(*arr)[5])//ok? 对，这是数组指针,指向的数组是5个元素
{}
void test(int** arr)//ok? 错，这是一个二级指针，可以储存一级指针
{}

int main() 
{
	int arr[3][5] = { 0 };
	test(arr);
	return 0;
}









