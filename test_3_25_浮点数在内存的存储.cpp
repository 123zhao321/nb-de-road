#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//浮点型在内存中的存储
// 
// 
// 
//常见的浮点数 :
//3.14159 1E10 浮点数家族包括 : f1oat、double、1ong doub1e类型。
//浮点数表示的范围 : float.h中定义
//
// 
// 
// 
//IEEE 754对有效数字M和指数E，还有一些特别规定。
//
//前面说过，1≤M < 2，也就是说，M可以写成 1.xxxxxx的形式，
//其中xxxxxx表示小数部分。
//IEEE 754规定，在计算机内部保存M时, 默认这个数的第一位总是1, 
//因此可以被舍去，只保存后面的xxxxxx部分比如保存1.01的时候, 只保存01,
//等到读取的时候，再把第一位的1加上去。
//这样做的目的，是节省1位有效数字.。以32位浮点数为例，
//留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字
//
//至于指数E，情况就比较复杂。
//
//首先，E为一个无符号整数(unsigned int)这意味着，
//如果E为8位，它的取值范围为0~255; 
//如果E为11位，它的取值范围为0~2047。
//但是，我们知道，科学计数法中的是可以出现负数的，
//所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，
//对于8位的E，这个中间数是127; 对于11位的E，这个中间数是1023。
//比如，2 ^ 10的E是10，
//所以保存成32位浮点数时，必须保存成10 + 127 = 137，即10001001
//


//
//然后，指数E从内存中取出还可以再分成三种情况
//
//
//E不全为0或不全为1（掌握这个即可）
//
//这时，浮点数就采用下面的规则表示，
//即指数E的计算值减去127(或1023), 得到真实值，
//再将有效数字M前加上第一位的1。
//比如:0.5 (1/2) 的二进制形式为0.1，由于规定正数部分必须为1, 
//即将小数点右移1位则为1.0 * 2 ^ (-1)，其阶码为 - 1 + 127 = 126，
//表示为01111110，而尾数1.0去掉整数部分为0，
//补齐0到23位00000000000000000000000，
//则其二进制表示形式为 :0 01111110 00000000000000000000000
//
//E全为0
//
//这时，浮点数的指数E等于1 - 127(或者1 - 1023)即为真实值，
//有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。
//这样做是为了表示 + 0，以及接近于0的很小的数字。
//
//E全为1
//
//这时，如果有效数字M全为0，表示 + 无穷大(正负取决于符号位s);
//
//好了，关于浮点数的表示规则，就说到这里

// 
// 虽然float和int都是4个字节的大小
// 但是储存和读取的方式不同，不能强制读取
// 

//num 和*pF1oat 在内存中明明是同一个数，
//为什么浮点数和整数的解读结果会差别这么大 ? 
//要理解这要搞懂浮点数在计算机内部的表示方法。
//
//详细解读 :
//根据国际标准IEEE(电气和电子工程协会) 754，
//任意一个二进制浮点数 V 可以表示成下面的形式 :
//
//(-1) ^ S * M * 2 ^ E
//
//(-1) ^ s	表示符号位，当 s = 0，V 为正数; 当 s = 1，V为负数。
//  M			表示有效数字，大于等于1，小于2。
//2 ^ E		表示指数位。
//（这不是异或，是指数）
//
//
//举例来说 : 
//
//十进制的5.0, 写成二进制是 101.0, 
//相当于1.01*2 ^ 2。那么，按照上面V的格式，
//可以得出s = 0，M = 1.01，E = 2。
//
//十进制的 - 5.0，写成二进制是 - 101.0, 
//相当于 - 1.01*2 ^ 2。那么，S = 1，M = 1.01，E = 2。



//浮点数存储的例子 :

//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//	printf("n的值为:%d\n",n); // 9
//	printf("*prloat的值为:%f\n", * pFloat); // 0.000000
//
//	*pFloat = 9.0;
//	printf("num的值为:%d\n",n); // 1091567616
//	printf("*pFloat的值为:%f\n", * pFloat); // 9.000000
//	return 0;
//}
//
//n是int类型的，%d 是正常输出 9 
//n的二进制表示是00000000 00000000 00000000 00001001
//如果是强制类型转换储存在pFloat中，再按浮点数输出
//
//对于浮点数来说，第一位是0，补码就是原码，
//所以被转换为0 00000000 0000000000000000001001
//s是0，E是 -127 = 0 - 127，M是0.0000000000000000000001001
//（-1）^ 0 * 0.000000000000000000010001 * 2 ^ -127
//
//总之来说，就是一个特别小的数字，
//因为浮点数默认输出的时候是小数点后6位，所以第二个输出是0.000000
//
//当 p 指针里面正常存储一个浮点数的时候，
//9.0 转换为二进制 1001.0，也就是(-1)^0 * 1.001 * 2 ^ 2
//s是0，E是2+127=129，M是001
//二进制序列就是 0 10000001 0010000000000000000000000
//
//因为也是正数，被%d当成整型输出，就是01000000 10010000 00000000 00000000
//是一个特别大的数字
//
//浮点数作为浮点数打印就是正常的 9.000000 了


//编码的三种境界:
//1.看代码就是代码 - 最普通的代码
//2.看代码就是内存 - 看的是内存的存储和使用
//3.看代码还是代码 - 人码合一（想让它干啥就干啥）
//
//
