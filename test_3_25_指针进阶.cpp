#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


//好书推荐 ---- 《剑指offer》
// 
//指针的进阶
// 
//1.字符指针
//2.数组指针
//3.指针数组
//4.数组传参和指针传参
//5.函数指针
//6.函数指针数组
//7.指向函数指针数组的指针
//8. 回调函数
//9.指针和数组面试题的解析


//指针的主题，我们在初级阶段的《指针》章节已经接触过了，我们知道了指针的概念
//1.指针就是个变量，用来存放地址，地址唯一标识一块内存空间。
//2.指针的大小是固定的4 / 8个字节(32位平台 / 64位平台)。
//3.指针是有类型，指针的类型决定了指针的 + - 整数的步长，
//	指针解引用操作的时候的权限,
//4.指针的运算。

//int main()
//{
//	//char ch='q';
//	//char *p = &ch;
//	//本质上是把"hello bit"这个字符串的首字符的地址存储在了p中
//	char arr[] = "hello bit";
//
////char* ps = "hello bit"; // c++环境中不允许这么写
//	const char *ps = "hello bit.";//c++环境支持
//	printf("%c\n", *ps);
//	printf("%s\n", ps);
//
//	printf("%s\n", arr);
//	return 0;
//}


// 
//代码 char* p = ""he1lo bit."
//特别容易让同学以为是把字符串he1lo bit放到字符指针 p 里了，
//但本质是把字符串 "he11o bit." 首字符的地址放到了 p 中
// 
//这个字符串没有实体储存，对于c++这中比较严谨的环境中无法运行
//需要加上const修饰
//

// 面试题

//int main()
//{
//	char strl[] = "hello bit.";
//	char str2[] = "hello bit.";
//	char* str3 = "hello bit.";
//	char* str4 = "hello bit.";
//
//	if (strl == str2)
//		printf("strl and str2 are same\n");
//	else
//		printf("strl and str2 are not same\n");
//
//	if (str3 == str4)
//		printf("str3 and str4 are same\n");
//	else
//		printf("str3 and str4 are not same\n");
//	return 0;
//
//}

// 1，2 是字符串数组，是两个不同的地址储存字符串
// 3，4 都是指针指向内存中一个"hello bit"的地方，
// 这个字符串不动，两个指针的地址都是这个字符串
// 1，2不同，3，4相同
// 


// 
//int main()
//{
//	const char* p = "hello";
//	printf("%c\n", *p);
//	printf("%s\n", p);
//	//*p = 'w';//error
//	return 0;
//}

// 这种字符串叫 常量字符串，不可以被更改，
// 因此指针字符串用const修饰

//打印字符串只需要地址
//是因为字符串在内存中是以连续的字符数组的形式存储的，
//而地址所指向的就是该字符数组的起始位置。
//因此，只需要地址就可以访问整个字符串。
//
//打印字符需要解引用是因为字符是单个字符而不是字符数组，
//因此需要通过解引用操作来访问字符本身。
//解引用操作是从存储字符的地址中读取实际的字符值。
//因此，需要解引用才能访问和打印字符本身。


//指针数组
//数组 - 数组中存放的是指针(地址)
//int*arr[3];
//存放整形指针的数组

//int main()
//{
//	
//	int a = 10;
//	int b = 20;
//	int c = 30;
//	int* arr[3] = { &a,&b,&c };//这种写法太土了
//
//	int i = 0;
//	for (i = 0; i < 3; i++)
//		printf("%d ", *(arr[i]));
//	return 0;
//}

// 指针数组
// 指针数组是一个数组，其中每个元素都是指针类型的指针。
// 这意味着，指针数组存储的是指针的地址。

//int main()
//{
//	int a[] = { 1,2,3,4,5 };
//	int b[] = { 2,3,4,5,6 };
//	int c[] = { 3,4,5,6,7 };
//
//	int* pa[3] = { a,b,c };// 这是每个数组首元素的地址
//	// 一个叫pa的数组里面，存放了三个 int* 的指针
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", pa[i][j]);
//		}
//		printf("\n");
//
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(pa[i]+j));
//		}
//		printf("\n");
//
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(*(pa+i)+j));
//		}
//		printf("\n\n");
//	}
//	return 0;
//}

//在表达式*pa+i中，*和+的优先级相同，因此从左到右的顺序执行。

// 这三种输出方式说明了什么？
// 
// 第一个pa[i][j],像一个二维数组的使用方式
// 但也不是二维数组，毕竟二维数组是连续存放数据的
// 
// 其实从第三个向上看，比较好解释
// 第三个 *(*(pa+i)+j) ，先是 pa + i ,就是 pa 数组首元素的地址 + i
// 即 pa 数组的第 i 个元素的地址，*解引用，就是第 i 个元素了
// 即第 i 个指针，第 i 个数组的首元素的地址（因为指针里面是地址）
// 
// 下一步就是 *(pa+i)+j ，*(pa+i)是第i个数组的首元素地址
// 然后 +j，就是第i个数组里面的第j个元素的地址
// 最后再*解引用，*(*(pa+i)+j) 就是第 i 个数组的第 j 个元素
// 
// 
// 对于 *(pa+i) 与 pa[i]
// 
// pa+i是一个指针的偏移量，即指针pa向后移动i个元素的位置。
// 而pa[i]是数组或者指针的第i个元素，
// 在使用时，系统会自动转换为 *(pa + i)。
// 因此，它们本质上是相同的。
//

// 数组指针
// 数组指针是一个指向数组的指针，它存储的是数组的起始地址。
// 可以使用数组指针来访问数组中的元素

// 可以将指针数组视为一个数组，
// 其中每个元素都是指向不同数据类型的指针，
// 而数组指针是指向整个数组的指针。
// 在使用它们时，需要格外小心，以确保正确地访问和操作数据。

int main()
{
	int arr[2][3] = { 1,2,3,4,5,6 };
	int i = 0;
	int j = 0;
	int (*pa)[3] = arr;

	//（*pa）加括号，让*先与pa结合，说明是一个指针
	// 再往外扩，int [3]，说明是有3个int型的数组

	for (i = 0; i < 2; i++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	printf("\n");

	for (i = 0; i < 2; i++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("%d ", *(arr[i]+j));
		}
		printf("\n");
	}
	printf("\n");
	
	for (i = 0; i < 2; i++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("%d ", *(*(pa + i) + j));
		}
		printf("\n");
	}
	return 0;
}
