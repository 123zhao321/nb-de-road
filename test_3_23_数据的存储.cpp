#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//深度剖析数据在内存中的存储
//本章重点
//1.数据类型详细介绍
//2.整形在内存中的存储:原码、反码、补码
//3.大小端字节序介绍及判断
//4.浮点型在内存中的存储解析
// 
//基本的内置类型
//char		//字符数据类型
//short		//短整型
//int			//整形
//1ong		//长整型
//1ong long	//更长的整形
//float		//单精度浮点数dd
//double		//双精度浮点数
//
//整形家族 :
//	char
//		unsigned char
//		signed char
//	short
//		unsigned short[int]
//		signed short[int]
//	int
//		unsigned int
//		signed int
//	long
//		unsigned long[int]
//		signed long[int]
//
//浮点数家族:
//	float
//	double
//
//构造类型 - 自定义类型
//	结构体类型 struct
//	数组
//	枚举 enum
//	联合体 union
//指针类型
//	int*
//	char*
//	float*
//	void*
//空类型
//	空返回类型 void test();
//	空函数参数 void test(void);
//	空指针 void* p；

//int main()
//{
//	int a = 10;
//	return 0;
//}

//数据在内存中以2进制的形式存储对于整数来说:
//整数二进制有3种表示形式:原码、反码、补码
//正整数:原码、反码、补码相同
//负整数 : 原码、反码、补码要进行计算的
//按照数据的数值直接写出的二进制序列就是原码
//原码的符号位不变，其他位按位取反，得到的就是反码
//反码+1，得到的就是补码
//
//
//对于复数来说：-10 
//10000000000000000000000000001010 原码
//11111111111111111111111111110101 反码 = 原码除符号位取反
//11111111111111111111111111110110 补码 = 反码 + 1
//
//想要让补码回到原码，也是符号位不变，先取反，再加1
//10000000000000000000000000001001
//10000000000000000000000000001010  还是 - 10 
//
//
//整数在内存中存储的是二进制的补码
//为什么呢 ?
//在计算机系统中，数值一律用补码来表示和存储。
//原因在于，使用补码，可以将符号位和数值域统一处理;
//同时，加法和减法也可以统一处理(CPU只有加法器)
//此外，补码与原码相互转换，其运算过程是相同的，
//不需要额外的硬件电路。
//
//因为cpu只有加法运算器，其他数学运算只能用加法模拟实现
//
//比如， 1 - 1 ，这个算式
//1 - 1 = 1 + （ - 1 )
// 1的原码是00000000000000000000000000000001
//-1的原码是10000000000000000000000000000001
//直接相加是10000000000000000000000000000010
//是-2
//
//如果用补码运算
//
//-1的补码是10000000000000000000000000000001 // 原码
//		  11111111111111111111111111111110 // 反码
//		  11111111111111111111111111111111 // 补码
// 1的补码是00000000000000000000000000000001
//加法运算是1   00000000000000000000000000000000
//头上的1超了，就被丢弃，结果就是00000000000000000000000000000000
//
//大小端介绍
//
//什么大端小端 :
//
//大端(存储)模式，
//	是指数据的低位保存在内存的高地址中，
//	而数据的高位，保存在内存的低地址中;
//小端(存储)模式，
//	是指数据的低位保存在内存的低地址中，
//	而数据的高位, 保存在内存的高地址中。
//
//就是一个变量有一个二进制的序列，看看怎么存放
//0x11223344
//如果内存是这样，由低到高，
//这个序列是0x11223344放进去，靠前的11是高位，但低地址，就是大端
//11是序列中的高位，44是低位
//
//高位放高地址就是小段
//高位放低地址就是大端
//
//
//为什么有大端和小端:
//为什么会有大小端模式之分呢 ? 这是因为在计算机系统中，
//我们是以字节为单位的，每个地址单元都对应着一个字节，
//一个字节为8bit。但是在C语言中除了8bit的char之外，
//还有16bit的short型，32bit的long型(要看具体的编译器)，
//另外，对于位数大于8位的处理器，例如16位或者32位的处理器，
//由于寄存器宽度大于一个字节，
//那么必然存在着一个如何将多个字节安排的问题。
//因此就导致了大端存储模式和小端存储模式。
//
//例如一个 16bit 的 short型x, 在内存中的地址为 0x0010，
//x的值为 0x1122, 那么0x11为高字节，0x22为低字节。
//对于大端模式，就将 0x11放在低地址中，即 0x0010中，
//0x22放在高地址中，即 0x0011中。
//小端模式，刚好相反。我们常用的 x86 结构是小端模式，
//而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。
//有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。
//
//下次是101课