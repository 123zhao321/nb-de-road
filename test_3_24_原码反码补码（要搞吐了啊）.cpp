#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//int main()
//{
//	int a = 1; // 0x000000001
//	int* p = &a;
//	printf("%p\n", &a);
//
//	printf("%p\n", p);
//	p++;
//	printf("%p\n", p);
//
//	char* pa = (char*) & a;
//
//	printf("%p\n", pa);
//	printf("%d\n", *pa);
//
//	pa++;
//
//	printf("%p\n", pa);
//	printf("%d\n", *pa);
//
//	return 0;
// }

// 这个代码可以查看当前的编译器是大端储存还是小端存储
// 
// 这个a用十六进制表示应该是 0x 00 00 00 01
// 
// 用整型 *p 获取整型 a 的地址，
// 再 p++ 可以看到一个整型内存的大小
// 
// 再用字符指针获取 a 地址中的第一个字节的地址
// 因为整型是占用 4 个字节，char*可以获取第一个字节
// 经过检验发现 *pa 就是第一个字节的地址
// 
// 发现结果是 1 ，说明 1 储存在第一个字节里面
// pa++ 获取下一个字节的地址，发现是 0 
// 
// 因此，01 作为 a 的低位存储在 a 地址的低地址处
// 也就是低位在低地址，是小端存储
// 
//

//输出什么?
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	return 0;
//}

// char的大小是-128 到 127
// char大部分编译器默认是 signed char 是有符号的
// 
// 所以 signed char也是 -128 到 127
// 
// unsigned char 是 0 到 255
// 
// 因为-1是整型，原码是10000000 00000000 00000000 00000001
// 内存里面存的是补码，反码就是11111111 11111111 11111111 11111110
// 补码就是，反码 + 1 .11111111 11111111 11111111 11111111
// 
// char a 就是 11111111 
// 再换到 %d 整型输出，需要整型提升
// 按char的符号位补满空缺，就是前面全补符号位
// 即 11111111 11111111 11111111 11111111 就是 - 1
// 
// signed char a 就是 11111111
// 和 char 一样，都是 -1
// 
// unsigned char a 就是 11111111
// 无符号的整型提升高位补0。
// 因为无符号的整型只包含正数，
// 因此在进行整型提升时，
// 高位补0可以保持数值的正号不变。
// 
// 所以，unsigned char 就是 00000000 00000000 00000000 11111111 就是255
//
// 所以打印结果就是，a = -1, b = -1, c = 255
//
//补充:
// 1.char 到底是signed char 还是unsigned char ？
// c语言标准并没有规定，取决于编译器
// 
// 可以肯定的是：
// int 是 signed int
// shdrt 是 signed short


//int main()
//{
//	char a = -128;
//	printf("%u\n", a);
//	return 0;
//}

// -128 的整型
// 原码是 10000000 00000000 00000000 10000000
// 反码是 11111111 11111111 11111111 01111111
// 补码是 11111111 11111111 11111111 10000000
// 
// char 储存就是 10000000
// 因为char 是有符号位
// 对于char类型的整型提升，
// 如果char是有符号的，那么高位补符号位（即最高位的值），
// 如果char是无符号的，那么高位补0。
// 
// 所以，char 整型提升就是 11111111 11111111 11111111 10000000（补码）
// 
// %u 认为补码的高位不是符号位，
// 因为 %u 都是正整数，认为补码就是原码
// 会将补码直接打印，所以打印结果很奇怪的数字
//

//int main()
//{
//	char a = 128;
//	printf("%u\n", a);
//	return 0;
//}

// 128 原码就是补码，00000000 00000000 00000000 10000000
// 对于 char 类型来说 ，只能储存 10000000
// 然后整型提升 11111111 11111111 11111111 10000000
// 发现和上面那个-128的结果是一样的
//
// 
// 
// 
// 对于char来说
// 在内存里面应用的时候，都是用补码
// 因为char是有符号的
// 所以从 00000000 到 11111111
// 
// 00000000 是 0
// 00000001 是 1
// 00000010 是 2
// ...
// 01111111 是 127
// 10000000 是-128
// 10000001  反码是11111110 ，原码就是 11111111 是-127
// 10000010 是-126
// 10000011 是-125
// ...
// 11111111 反码是10000000 ， 原码是 10000001 是 -1
// 
// 
// 所以char 类型没有128，127+1的结果就是-128
//

//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("&d\n", i + j);
//	return 0;
//}

// 无符号的10，补码还是10，变成有符号也是10
// -20 的原码是 10000000 00000000 00000000 00010100
// 反码			11111111 11111111 11111111 11101011
// 补码			11111111 11111111 11111111 11101100
// 10 的补码	00000000 00000000 00000000 00001010
// 加和就是		11111111 11111111 11111111 11110110
// 取反，反码	10000000 00000000 00000000 00001001
// 原码就是		10000000 00000000 00000000 00001010 就是 -10
// 
//
// 如果无符号的一个正数，最高位是1，强制转换的时候，怎么办？
// 
//当将一个无符号的数（最高位为1）强制转换为有号类型时，会发生符号扩展。
//符号扩展意味着最高位的1被解释为有符数的符号位，而不是其实际值。
//这可能导致意外的结果，因此在进行这样的换时需要格外小心。
//例如，假设有一个无符号的8位整型数0xFF（所有位都是1），
//在将其转换为有符号类型时，最高位的1会被解释为负数标志，
//导致负数的数值。因此，转换后的结果可能不是我们期望的正数。
//进行这样的转换时，应该谨慎考虑数据的实际含义和范围，
//并且需要对转换后可能的溢出情况进行充分的考虑。


//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("&u\n", i);
//	}
//	return 0;
//}

// 当 i = 0 时，条件符合会继续 i--
// 因为 i 是无符号的整型
// 则 i-- 的结果是一个特别大的整数，依旧符合i>=0,这个条件
// 所以上面这个代码会无限循环
// 

//#include <string.h>
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d",strlen(a));
//	return 0;
//}

// 当 i = 0 时，- 1 - i = - 1 
// -1的原码是	10000000 00000000 00000000 00000001
// 反码			11111111 11111111 11111111 11111110
// 补码			11111111 11111111 11111111 11111111
// char 类型储存的补码是 11111111
// 反码 10000000 原码 10000001 是-1 
// 
// i = 1 时 储存 -2
// i = 2         -3
// ...
// i = 126 是 -127
// 原码是 10000000 00000000 00000000 01111111
// 反码   11111111 11111111 11111111 10000000
// 补码   11111111 11111111 11111111 10000001
// char的补码是 10000001
// 反码是 11111110
// 原码   11111111
// a[126] = -127
// 
// i = 127 
// -128原码 10000000 00000000 00000000 10000000
// 反码		11111111 11111111 11111111 01111111
// 补码		11111111 11111111 11111111 10000000
// char 储存 10000000 是-128
// 
// i = 128
// 就是 -129
// 原码 10000000 00000000 00000000 10000001
// 反码 11111111 11111111 11111111 01111110
// 补码 11111111 11111111 11111111 01111111
// char 储存 01111111 是127
// 
// 然后依次递减到0，再递增
// 
// a数组里面就是
// -1，-2，-3....-127， -128 ， 127 ，126，125，..3，2，1 0，-1，-2....
// 
// strlen函数读取数组a时，遇到 0 就截止了，结果就是128+127=255
// 


//unsigned char i = 0;
//
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}

// 也是死循环，因为 i 一直符合 i <= 255,这个条件
// 当 i = 255 时，再循环又会变成 0 
//